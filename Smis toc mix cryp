
#enfa 0*(01)*0*
def transition(state, symbol):
    if state == 0 and symbol == '0':
        return {0}
    elif state == 0 and symbol == '1':
        return {1}
    elif state == 1 and symbol == '0':
        return {1}
    elif state == 1 and symbol == '1':
        return {2}
    elif state == 2 and symbol == '0':
        return {2}
    else:
        return set()


def is_accepted(input_string):
    current_states = {0}

    for symbol in input_string:
        next_states = set()
        for state in current_states:
            next_states |= transition(state, symbol)
        current_states = next_states

    return 2 in current_states


input_string = input("Enter a string: ")
if is_accepted(input_string):
    print("Accepted")
else:
    print("Not Accepted")





#enfa(a+b)*.a
def transition(state, symbol):
    if state == 0 and symbol == 'a':
        return {0, 1}
    elif state == 0 and symbol == 'b':
        return {0}
    elif state == 1 and symbol == 'a':
        return {1}
    elif state == 1 and symbol == 'b':
        return {1}
    else:
        return set()


def is_accepted(input_string):
    current_states = {0}

    for symbol in input_string:
        next_states = set()
        for state in current_states:
            next_states |= transition(state, symbol)
        current_states = next_states

    return 1 in current_states

input_string = input("Enter a string: ")
if is_accepted(input_string):
    print("Accepted")
else:
    print("Not Accepted")






#enfa(a+b)*.a
def transition(state, symbol):
    if state == 0 and symbol == 'a':
        return {0, 1}
    elif state == 0 and symbol == 'b':
        return {0}
    elif state == 1 and symbol == 'a':
        return {1}
    elif state == 1 and symbol == 'b':
        return {1}
    else:
        return set()


def is_accepted(input_string):
    current_states = {0}

    for symbol in input_string:
        next_states = set()
        for state in current_states:
            next_states |= transition(state, symbol)
        current_states = next_states

    return 1 in current_states

input_string = input("Enter a string: ")
if is_accepted(input_string):
    print("Accepted")
else:
    print("Not Accepted")




#cfg to pda
nt=int(input("\nEnter the number of non terminals capital letters():"))
NT=[]
for i in range(nt):
    print("\nEnter the non terminal:",i+1)
    item=input()
    NT.append(item)

t=int(input("\nEnter the number terminals(small letters):"))
T=[]
for i in range(t):
    print("\nEnter the non terminal:",i+1)
    item=input()
    T.append(item)
p=int(input("\nEnter the number production:"))
tempr=[]
for i in range(p):
    print("\nEnter the production symbols:",i+1)
    item=input()
    tempr.append(item)
print(tempr)
pr={}
for i in tempr:
    pr[i]={}
    print("\nEnter the production for ",i,":")
    pr[i]=input()
print(pr)
states=['q0','q1','q2']
print("\n The transitions for the cfg to PDA are : ")
print(f"&(q0,^,z0)=(q1,{tempr[0]}-z0)")
for i in tempr :
    print(f"&(q1,^,{i})=(q1,{pr[i]})")
for i in T :
    print(f"&(q1,{i},{i})=(q1,^)")
print("&(q0,^,q2)=(q1,z0)")





# Initialization of the DFA

print(comma separated ip)

ns = set(input("Enter the states: ").split(","))
ni = set(input("Enter the inputs: ").split(","))
q = input("Enter the start state: ")
f = set(input("Enter the final states: ").split(","))
transitions = {}

for state in ns:
    transitions[state] = {}
    for inp in ni:
        transitions[state][inp] = input(f"Enter the next state for {state} on input {inp}: ")

# Main loop for validating strings
while True:
    ip = input("Enter the string to process: ")
    path = [q]

    for i in range(len(ip)):
        next=transitions[path[i]][ip[i]]
        path.append(next)

    print("Path:")
    for i in range(len(ip)):
        print(f"{path[i]}-{ip[i]}-->", end=" ")

    if path[-1] in f:
        print("\nInput accepted")
    else:
        print("\nInput rejected")

    choice = input("Do you want to validate another string? (y/n): ")
    if choice.lower() == "n":
        break






Mealy –



# Initialization of the Mealy machine
print(“comma separated ip”)

ns = set(input("Enter the states: ").split(","))
ni = set(input("Enter the inputs: ").split(","))
q = input("Enter the start state: ")

transitions = {}

for state in ns:
    transitions[state] = {}
    for inp in ni:
        next_state = input(f"Enter next state for {state} on input {inp}: ")
        output = input(f"Enter output for {state} on input {inp}: ")
        transitions[state][inp] = (next_state, output)

# Main loop for validating strings
while True:
    ip = input("Enter the string to process: ")
    path = [q]
    output_path = ""

    for i in range(len(ip)):
        next_state, output = transitions[path[i]][ip[i]]
        path.append(next_state)
        output_path += output

    print("Path:")
    for i in range(len(ip)):
        print(f"{path[i]}-{ip[i]}-->", end=" ")

    print("\nOutput sequence:", output_path)

    

    choice = input("Do you want to validate another string? (y/n): ")
    if choice.lower() == "n":
        break








MOORE

# Initialization of the MOORE machine
ns = set(input("Enter the states: ").split(","))
ni = set(input("Enter the inputs: ").split(","))
q = input("Enter the start state: ")

transitions = {}
outputs={}

for state in ns:
    transitions[state] = {}
    for inp in ni:
        next_state = input(f"Enter next state for {state} on input {inp}: ")
        transitions[state][inp] =next_state

for state in ns:
    outputs[state]=input(f" enter output for state {state} :")
# Main loop for validating strings
while True:
    ip = input("Enter the string to process: ")
    path = [q]
    output_path =outputs[q]

    for i in range(len(ip)):
        next_state= transitions[path[i]][ip[i]]
        path.append(next_state)
        output_path +=outputs[next_state]

    print("Path:")
    for i in range(len(ip)):
        print(f"{path[i]}-{ip[i]}-->", end=" ")

    print("\nOutput sequence:", output_path)

    
    choice = input("Do you want to validate another string? (y/n): ")
    if choice.lower() == "n":
        break









Dfa

class DFA:
    def __init__(self, starting_state, final_states, transitions):
        self.starting_state = starting_state
        self.final_states = final_states
        self.transitions = transitions

    def process_input_sequence(self, input_sequence):
        current_state = self.starting_state
        traversal_path = [current_state]

        for input_symbol in input_sequence:
            current_state_transition = self.transitions.get(current_state, {})
            if input_symbol in current_state_transition:
                next_state = current_state_transition.get(input_symbol)
                traversal_path.append(f"{input_symbol} -> {next_state}")
                current_state = next_state
            else:
                print("Output: Your string is not valid")
                print(f"Reason: Invalid transition: State '{current_state}' with input '{input_symbol}'")
                return

        if current_state in self.final_states:
            print("Output: Your string is valid")
        else:
            print("Output: Your string is not valid")
            print(f"Reason: Your string ends at state '{current_state}' which is not a final state")

        print("Traversal Path: " + " - ".join(traversal_path))


def main():
    message = "Enter valid input symbols (∑) (comma-separated): "
    valid_input_string = input(message)
    valid_inputs = set(valid_input_string.split(","))

    message = "Enter states (Q) (comma-separated): "
    state_string = input(message)
    states = set(state_string.split(","))

    message = "Enter starting state (q0): "
    starting_state = input(message)

    message = "Enter all final states (F) (comma-separated): "
    final_state_string = input(message)
    final_states = set(final_state_string.split(","))

    transitions = {}

    for state in states:
        transitions[state] = {}
        for valid_input in valid_inputs:
            message = f"Enter transition (δ) for state '{state}' having input '{valid_input}': "
            next_state = input(message)
            transitions[state][valid_input] = next_state

    dfa = DFA(starting_state, final_states, transitions)

    while True:
        message = "Enter string to be validated: "
        input_sequence = input(message)
        dfa.process_input_sequence(input_sequence)

        choice = input("Do you want to validate another string? (y/n): ")
        if choice.lower() == "n":
            break


if __name__ == "__main__":
    main()




Mealy

class MealyMachine:
    def __init__(self, starting_state, transitions):
        self.starting_state = starting_state
        self.transitions = transitions

    def process_input_sequence(self, input_sequence):
        current_state = self.starting_state
        output_sequence = ""
        traversal_path = [current_state]

        for input_symbol in input_sequence:
            current_state_transition = self.transitions.get(current_state, {})
            if input_symbol in current_state_transition:
                next_state, output = current_state_transition[input_symbol]
                output_sequence += output
                traversal_path.append(f"{current_state}({input_symbol},{output})->{next_state}")
                current_state = next_state
            else:
                print("Output: Your input sequence is not valid")
                print(f"Reason: Invalid transition: State '{current_state}' with input '{input_symbol}'")
                return

        print("Output Sequence:", output_sequence)
        print("Traversal Path:", " -> ".join(traversal_path))


def main():
    message = "Enter valid input symbols (comma-separated): "
    valid_input_string = input(message)
    valid_inputs = set(valid_input_string.split(","))

    message = "Enter states (Q) (comma-separated): "
    state_string = input(message)
    states = set(state_string.split(","))

    message = "Enter starting state (q0): "
    starting_state = input(message)

    transitions = {}

    for state in states:
        transitions[state] = {}
        for valid_input in valid_inputs:
            message = f"Enter next state for transition '{state}' with input '{valid_input}': "
            next_state = input(message)
            message = f"Enter output for transition '{state}' with input '{valid_input}': "
            output = input(message)
            transitions[state][valid_input] = (next_state, output)

    mealy_machine = MealyMachine(starting_state, transitions)

    while True:
        message = "Enter input sequence to be processed: "
        input_sequence = input(message)
        mealy_machine.process_input_sequence(input_sequence)

        choice = input("Do you want to process another input sequence? (y/n): ")
        if choice.lower() == "n":
            break


if __name__ == "__main__":
    main()




Moore


class MooreMachine:
    def __init__(self, starting_state, transitions, outputs):
        self.starting_state = starting_state
        self.transitions = transitions
        self.outputs = outputs

    def process_input_sequence(self, input_sequence):
        current_state = self.starting_state
        output_sequence = self.outputs[current_state]  # Include the initial state's output
        traversal_path = [current_state]

        for input_symbol in input_sequence:
            current_state_transition = self.transitions.get(current_state, {})
            if input_symbol in current_state_transition:
                next_state = current_state_transition[input_symbol]
                output_sequence += self.outputs[next_state]  # Get output associated with the next state
                traversal_path.append(f"{current_state}({input_symbol},{self.outputs[next_state]})->{next_state}")
                current_state = next_state
            else:
                print("Output: Your input sequence is not valid")
                print(f"Reason: Invalid transition: State '{current_state}' with input '{input_symbol}'")
                return

        print("Output Sequence:", output_sequence)
        print("Traversal Path:", " -> ".join(traversal_path))


def main():
    message = "Enter valid input symbols (comma-separated): "
    valid_input_string = input(message)
    valid_inputs = set(valid_input_string.split(","))

    message = "Enter states (Q) (comma-separated): "
    state_string = input(message)
    states = set(state_string.split(","))

    message = "Enter starting state (q0): "
    starting_state = input(message)

    outputs = {}  # Modify to store outputs associated with states

    for state in states:
        message = f"Enter output for state '{state}': "
        output = input(message)
        outputs[state] = output

    transitions = {}

    for state in states:
        transitions[state] = {}
        for valid_input in valid_inputs:
            message = f"Enter next state for transition '{state}' with input '{valid_input}': "
            next_state = input(message)
            transitions[state][valid_input] = next_state

    moore_machine = MooreMachine(starting_state, transitions, outputs)

    while True:
        message = "Enter input sequence to be processed: "
        input_sequence = input(message)
        moore_machine.process_input_sequence(input_sequence)

        choice = input("Do you want to process another input sequence? (y/n): ")
        if choice.lower() == "n":
            break


if __name__ == "__main__":
    main()







Cfg to pda

rules = [input().split() for _ in range(int(input("Enter number of production rules: ")))]

non_terminals = {rule[0] for rule in rules}
terminals = set()
for rule in rules:
    for prod in rule[1].split('|'):
        for ch in prod:
            if ch.islower() or ch.isdigit():
                terminals.add(ch)
terminals.add('#')

print("PDA Production Rules:")
for non_term in non_terminals:
    print(f"dl(q,null,{non_term}) --> ", end='')
    first = True
    for rule in rules:
        if rule[0] == non_term:
            for prod in rule[1].split('|'):
                if not first:
                    print(" | ", end='')
                print(f"dl(q,{prod})", end='')
                first = False
    print()

for term in terminals:
    if term == '#':
        print("dl(q,null,null) --> dl(q,null)")
    else:
        print(f"dl(q,{term},{term}) --> dl(q,null)")






Cfg to cnf

import string

def remove_char(string, pos):
    new_string = ""
    for i in range(len(string)):
        if str(i) not in pos:
            new_string += string[i]
    return new_string

from itertools import permutations

NT_symbol = input("Enter the NonTerminal Symbols: ").split(" ")
T_symbol = input("Enter the Terminal Symbols: ").split(" ")

main = {}

#Eliminating NULL Production
n = []
for i in NT_symbol:
    main[i] = input(i + " -> ").split("/")

for i in main:
    for k in main[i]:
        for u in k:
            if u=="^":
                n.append(i)
                break

n = [*set(n)]
for i in main:
    for k in main[i]:
        pos = ""
        m = []
        possible_comb = []

        for u in range(len(k)):
            if k[u] in n:
                    pos += str(u)

        for b in range(len(pos)):
            temp = [''.join(p) for p in permutations(pos, b + 1)]
            possible_comb = possible_comb + temp

        for b in possible_comb:
            new_k = k
            if k != "^":
                m.append(remove_char(k, b))
        main[i] = main[i] + list(set(m))
    main[i] = [production.replace('^', '') for production in main[i]]

# Removing unit productions
unit_prod = {}

for i in NT_symbol:
    unit_prod[i] = []

for i in main:
    for b in main[i]:
        if b in NT_symbol:
            unit_prod[i].append(b)

for i in unit_prod:
    for j in unit_prod[i]:
        for k in main[i]:
            if k == j:
                main[i].remove(k)

for i in unit_prod:
    for mt in unit_prod[i]:
                for k in main[mt]:
                    main[i].append(k)

print("\nAFTER REMOVING NULL AND UNIT PRODUCTION")
for i in main:
    print(i + " -> ", end="")
    for ele in range(len(main[i])):
        if(main[i][ele]!=""):
            b = main[i][ele]
            print(b, end="/")
    print()

print("\nConverting to CNF form: ")

letter = len(string.ascii_uppercase)

for sym in NT_symbol:
    for i in range(len(main[sym])):
        b = main[sym][i]
        count_NT = 0
        count_T = 0

        for j in b:
            if j.isupper():
                count_NT += 1
            elif j.islower():
                count_T += 1

        if count_NT == 3:
            New_NT = string.ascii_uppercase[letter - 1]
            letter -= 1
            NT_symbol.append(New_NT)
            main[New_NT] = [b[0:2]]
            main[sym][i] = New_NT + b[2]

        elif count_T == 1 and count_NT == 2:
            New_NT = string.ascii_uppercase[letter - 1]
            letter -= 1
            NT_symbol.append(New_NT)
            main[New_NT] = [b[0]]
            New_NT2 = string.ascii_uppercase[letter - 1]
            letter -= 1
            NT_symbol.append(New_NT2)
            main[New_NT2] = [b[1:]]
            main[sym][i] = New_NT + New_NT2

        elif count_T == 1 and count_NT == 1:
            New_NT = string.ascii_uppercase[letter - 1]
            letter -= 1
            NT_symbol.append(New_NT)
            main[New_NT] = [b[0]]
            main[sym][i] = New_NT + b[1]
        
        elif count_T == 2 and count_NT == 1:
            New_NT = string.ascii_uppercase[letter - 1]
            letter -= 1
            NT_symbol.append(New_NT)
            main[New_NT] = [b[0]]
            New_NT1 = string.ascii_uppercase[letter - 1]
            letter -= 1
            NT_symbol.append(New_NT1)
            main[New_NT1] = [b[1]]
            main[sym][i] = New_NT + New_NT1+b[2]
            b=main[sym][i]
            New_NT2 = string.ascii_uppercase[letter - 1]
            letter -= 1
            NT_symbol.append(New_NT2)
            main[New_NT2] = [b[0:2]]
            main[sym][i] = New_NT2+b[2]
        elif count_T == 2 and count_NT == 0:
            New_NT = string.ascii_uppercase[letter - 1]
            letter -= 1
            NT_symbol.append(New_NT)
            main[New_NT] = [b[0]]
            New_NT1 = string.ascii_uppercase[letter - 1]
            letter -= 1
            NT_symbol.append(New_NT1)
            main[New_NT1] = [b[1]]
            main[sym][i] = New_NT + New_NT1
        elif count_T == 2 and count_NT == 2:
            New_NT = string.ascii_uppercase[letter - 1]
            letter -= 1
            NT_symbol.append(New_NT)
            main[New_NT] = [b[0]]
            New_NT1 = string.ascii_uppercase[letter - 1]
            letter -= 1
            NT_symbol.append(New_NT1)
            main[New_NT1] = [b[1]]
            main[sym][i] = New_NT + New_NT1 + b[2:]
            
            b=main[sym][i]
            New_NT = string.ascii_uppercase[letter - 1]
            letter -= 1
            NT_symbol.append(New_NT)
            main[New_NT] = [b[0:2]]
            New_NT1 = string.ascii_uppercase[letter - 1]
            letter -= 1
            NT_symbol.append(New_NT1)
            main[New_NT1] = [b[2:]]
            main[sym][i] = New_NT + New_NT1


for i in main:
    print(i + " -> ", end="")
    unique_productions = set()
    for ele in range(len(main[i])):
        if main[i][ele] != "":
            b = main[i][ele]
            if b not in unique_productions:
                print(b, end="/")
                unique_productions.add(b)
    
    print()

    
    
    


Enfa


class Type:
    SYMBOL = 1
    CONCAT = 2
    UNION  = 3
    KLEENE = 4

class ExpressionTree:

    def __init__(self, _type, value=None):
        self._type = _type
        self.value = value
        self.left = None
        self.right = None
    

def constructTree(regexp):
    stack = []
    for c in regexp:
        if c.isalpha():
            stack.append(ExpressionTree(Type.SYMBOL, c))
        else:
            if c == "+":
                z = ExpressionTree(Type.UNION)
                z.right = stack.pop()
                z.left = stack.pop()
            elif c == ".":
                z = ExpressionTree(Type.CONCAT)
                z.right = stack.pop()
                z.left = stack.pop()
            elif c == "*":
                z = ExpressionTree(Type.KLEENE)
                z.left = stack.pop()
            stack.append(z)

    return stack[0]

def inorder(et):
    if et._type == Type.SYMBOL:
        print(et.value)
    elif et._type == Type.CONCAT:
        inorder(et.left)
        print(".")
        inorder(et.right)
    elif et._type == Type.UNION:
        inorder(et.left)
        print("+")
        inorder(et.right)
    elif et._type == Type.KLEENE:
        inorder(et.left)
        print("*")

def higherPrecedence(a, b):
    p = ["+", ".", "*"]
    return p.index(a) > p.index(b)

def postfix(regexp):
    # adding dot "." between consecutive symbols
    temp = []
    for i in range(len(regexp)):
        if i != 0\
            and (regexp[i-1].isalpha() or regexp[i-1] == ")" or regexp[i-1] == "*")\
            and (regexp[i].isalpha() or regexp[i] == "("):
            temp.append(".")
        temp.append(regexp[i])
    regexp = temp
    
    stack = []
    output = ""

    for c in regexp:
        if c.isalpha():
            output = output + c
            continue

        if c == ")":
            while len(stack) != 0 and stack[-1] != "(":
                output = output + stack.pop()
            stack.pop()
        elif c == "(":
            stack.append(c)
        elif c == "*":
            output = output + c
        elif len(stack) == 0 or stack[-1] == "(" or higherPrecedence(c, stack[-1]):
            stack.append(c)
        else:
            while len(stack) != 0 and stack[-1] != "(" and not higherPrecedence(c, stack[-1]):
                output = output + stack.pop()
            stack.append(c)

    while len(stack) != 0:
        output = output + stack.pop()

    return output

class FiniteAutomataState:
    def __init__(self):
        self.next_state = {}

def evalRegex(et):
    # returns equivalent E-NFA for given expression tree (representing a Regular
    # Expression)
    if et._type == Type.SYMBOL:
        return evalRegexSymbol(et)
    elif et._type == Type.CONCAT:
        return evalRegexConcat(et)
    elif et._type == Type.UNION:
        return evalRegexUnion(et)
    elif et._type == Type.KLEENE:
        return evalRegexKleene(et)

def evalRegexSymbol(et):
    start_state = FiniteAutomataState()
    end_state   = FiniteAutomataState()
    
    start_state.next_state[et.value] = [end_state]
    return start_state, end_state

def evalRegexConcat(et):
    left_nfa  = evalRegex(et.left)
    right_nfa = evalRegex(et.right)

    left_nfa[1].next_state['epsilon'] = [right_nfa[0]]
    return left_nfa[0], right_nfa[1]

def evalRegexUnion(et):
    start_state = FiniteAutomataState()
    end_state   = FiniteAutomataState()

    up_nfa   = evalRegex(et.left)
    down_nfa = evalRegex(et.right)

    start_state.next_state['epsilon'] = [up_nfa[0], down_nfa[0]]
    up_nfa[1].next_state['epsilon'] = [end_state]
    down_nfa[1].next_state['epsilon'] = [end_state]

    return start_state, end_state

def evalRegexKleene(et):
    start_state = FiniteAutomataState()
    end_state   = FiniteAutomataState()

    sub_nfa = evalRegex(et.left)

    start_state.next_state['epsilon'] = [sub_nfa[0], end_state]
    sub_nfa[1].next_state['epsilon'] = [sub_nfa[0], end_state]

    return start_state, end_state

def printStateTransitions(state, states_done, symbol_table):
    if state in states_done:
        return

    states_done.append(state)

    for symbol in list(state.next_state):
        line_output = "q" + str(symbol_table[state]) + "\t\t" + symbol + "\t\t\t"
        for ns in state.next_state[symbol]:
            if ns not in symbol_table:
                symbol_table[ns] = 1 + sorted(symbol_table.values())[-1]
            line_output = line_output + "q" + str(symbol_table[ns]) + " "

        print(line_output)

        for ns in state.next_state[symbol]:
            printStateTransitions(ns, states_done, symbol_table)

def printTransitionTable(finite_automata):
    print("State\tSymbol\tNext state")
    printStateTransitions(finite_automata[0], [], {finite_automata[0]:0})


r = input("Enter regex: ")
pr = postfix(r)
et = constructTree(pr)

#inorder(et)

fa = evalRegex(et)
printTransitionTable(fa)





turing ---


transitions = [[1,5,4,5,3], 
              [1,2,5,5,1],
              [2,5,5,0,2],
              [5,5,4,5,3],
              [4,4,4,4,4],
              [5,5,5,5,5]]

symbols = ["0","1"," ","x","y"]

pointer = [[1,1,0,1,1], [1,0,1,1,1],
           [0,1,1,1,0], 
           [1,1,0,1,1],
           [1,1,1,1,1],
           [1,1,1,1,1]]
           
replace = [[3,3,3,3,4], [0,4,3,3,4],
           [0,3,3,3,4],
           [0,1,2,3,4],
           [0,1,2,3,4],
           [0,1,2,3,4]]
           
state = 0

s = input("enter the string: ")
s = list(s + " ")

acc = 4
dec = 5 

tape = s
head = 0
i = 20

print("Tape: ", end="")
print(tape)
print("State = "+str(state) + ", Head = "+ str(head))

while state < 4:
  c = state
  
  symbol = symbols.index(tape[head]) # get index of symbol
  
  tape[head] = symbols[replace[c][symbol]] 
  state = transitions[c][symbol]
  
  if pointer[c][symbol] == 0:
    head -= 1
  else:
    head += 1
    
  print("Tape: ", end="")
  print(tape)
  
  print("State = "+str(state) + ", Head = "+ str(head))
  
  if state == 4:
    print("the given string passes")
  else:
    print("the given string does not pass")





























Smis




	1.	Mean , median , mode

def calculate_mean(numbers):
    return sum(numbers) / len(numbers)

def calculate_median(numbers):
    sorted_numbers = sorted(numbers)
    n = len(sorted_numbers)
    
    if n % 2 == 0:
        mid1 = sorted_numbers[n // 2 - 1]
        mid2 = sorted_numbers[n // 2]
        median = (mid1 + mid2) / 2
    else:
        median = sorted_numbers[n // 2]
    
    return median

def calculate_mode(numbers):
    frequency = {}
    
    for num in numbers:
        frequency[num] = frequency.get(num, 0) + 1
    
    max_freq = max(frequency.values())
    mode = [key for key, value in frequency.items() if value == max_freq]
    
    return mode

# Input the data
data = [int(x) for x in input("Enter the space-separated numbers: ").split()]

# Calculate and print the mean, median, and mode
mean_value = calculate_mean(data)
median_value = calculate_median(data)
mode_value = calculate_mode(data)

print(f"Mean: {mean_value}")
print(f"Median: {median_value}")
print(f"Mode: {mode_value}")



	1.	GM, HM

def calculate_geometric_mean(numbers):
    product = 1
    
    for num in numbers:
        product *= num
    
    geometric_mean = product**(1/len(numbers))
    return geometric_mean

def calculate_harmonic_mean(numbers):
    reciprocal_sum = sum(1/num for num in numbers)
    
    harmonic_mean = len(numbers) / reciprocal_sum
    return harmonic_mean

# Input the data
data = [float(x) for x in input("Enter the space-separated numbers: ").split()]

# Calculate and print the geometric and harmonic mean
geometric_mean_value = calculate_geometric_mean(data)
harmonic_mean_value = calculate_harmonic_mean(data)

print(f"Geometric Mean: {geometric_mean_value}")
print(f"Harmonic Mean: {harmonic_mean_value}")






Skewness


def calculate_mean(numbers):
    return sum(numbers) / len(numbers)

def calculate_median(numbers):
    sorted_numbers = sorted(numbers)
    n = len(sorted_numbers)
    
    if n % 2 == 0:
        mid1 = sorted_numbers[n // 2 - 1]
        mid2 = sorted_numbers[n // 2]
        median = (mid1 + mid2) / 2
    else:
        median = sorted_numbers[n // 2]
    
    return median

def calculate_standard_deviation(numbers, mean_value):
    n = len(numbers)
    squared_diff = sum((x - mean_value)**2 for x in numbers)
    variance = squared_diff / n
    std_deviation = variance**0.5
    return std_deviation

def calculate_karl_pearson_skewness(numbers):
    mean_value = calculate_mean(numbers)
    median_value = calculate_median(numbers)
    std_deviation = calculate_standard_deviation(numbers, mean_value)

    skewness = 3 * (mean_value - median_value) / std_deviation
    return skewness

# Input the data
data = [float(x) for x in input("Enter the space-separated numbers: ").split()]

# Calculate and print the Karl Pearson skewness
skewness_value = calculate_karl_pearson_skewness(data)

print(f"Karl Pearson Skewness: {skewness_value:.4f}")




Chi 


Chi square


data = []
for i in range(int(input("Enter the number of terms: "))):
    ob = int(input(f"Enter the observed frequency {i + 1}: "))
    ex = int(input(f"Enter the expected frequency {i + 1}: "))
    data.append((ob, ex))

print("Items:", data)

chi = 0
for o, e in data:
    chi += ((o - e) ** 2 / e)

print("Calculated Chi-square:", chi)

critical_value = float(input("Enter the critical value for chi-square test: "))

if chi > critical_value:
    print("Reject the null hypothesis")
else:
    print("Accept the null hypothesis")







2. chi



c_value = float(input("Enter the critical value : "))
terms=int(input("Enter the number of terms: "))
attributes=int(input("Enter the number of attributes: "))
data_list = []
for i in range(attributes):
    print(f'Enter value for attribute {i+1}:')
    row = []
    for j in range(terms):
        num = float(input(f'Enter term {j+1} for attribute {i+1} : '))
        row.append(num)
    data_list.append(row)
print(data_list)
        
horizontal_sum = []
for i in range(terms):
    tot = 0
    for j in range(attributes):
        tot += data_list[j][i]
    horizontal_sum.append(tot)
    
vertical_sum = []
for i in range(attributes):
    pot = 0
    for j in range(terms):
        pot+= data_list[i][j]
    vertical_sum.append(pot)
print(vertical_sum)

total_sum = sum(horizontal_sum)

expected_value = []
for i in range(attributes):
    row1 = []
    for j in range(terms):
        exp = (vertical_sum[i]*horizontal_sum[j])/total_sum
        row1.append(exp)
    expected_value.append(row1)
    
output_list = []
for i in range(attributes):
    
    for j in range(terms):
        exp = (((data_list[i][j])-expected_value[i][j])**2)/expected_value[i][j]
        
    output_list.append(exp)
final_output = sum(output_list)
print(f'The chi square value of the given dataset is {final_output}')
if(final_output>c_value):
    print('Null rejected, Alternate accepted')
else:
    print('Null not rejected, alternate rejected')



CPPPP




mean med mode

#include<iostream>
#include<algorithm>
using namespace std;
int main(){
    //mean= average of given data
    //median= middle term after data in ascendongor descending order
    //mode=highest repeated term
    int max=0, mode=0, n, count=0;
    float mean=0, median, arr[50], temp=0;
    cout<<"enter number of elements"<<endl;
    cin>>n;
    cout<<"enter the elements in any order"<<endl;
    
    for(int i=0;i<n;i++){
        cin>>arr[i];
        mean=mean +arr[i];
    }
    mean=mean/n;
    cout<<"mean="<<mean<<endl;

    sort(arr,arr + n);
    if(n%2==0){
        median=(arr[((n/2)-1)]+arr[(n/2)])/2.0;
        cout<<"median="<<median<<endl;
    }
    else{
        median=arr[((n-1)/2)];
        cout<<"median="<<median<<endl;
    }

    for(int i=0;i<n;i++){
        count=0;
        for(int j=0;j<n;j++){
            if(arr[i]==arr[j]){
                count++;
            }
        }
        if(count>max){
        max=count;
        mode=arr[i];
    }
    }
cout<<"mode="<<mode<<endl;
}
////////////////////////////////////////////////////////////////////////////////////

gmhm

#include<iostream>
#include<math.h>
using namespace std;
int main(){
    //gm- done to find exponential growth or decay in data, helps dealing with extreme values
    //hm- mean of inversed components(reciprocal)(speed, time)
    int n;
    float mean=0, x=0, y=0, hm=0, arr[20];
    cout<<"enter no. of elements"<<endl;
    cin>>n;
    cout<<"enter the elements"<<endl;
    for(int i=0;i<n;i++){
        cin>>arr[i];
    }

    for(int i=0;i<n;i++){
        mean=mean + log10(arr[i]);
    }
    int value=mean/n;
    double gm=pow(10,value);
    cout<<"geometric mean="<<gm<<endl;
    
    for(int i=0;i<n;i++){
        x=1/arr[i];
        y=y+x;
    }
    hm=n/y;
    cout<<"harmonic mean="<<hm<<endl;
}
///////////////////////////////////////////////////////////////////////////////////////////

skew

#include<iostream>
#include <cmath>
using namespace std;
int main(){
    //measure of skewness helps in finding direction of skew ness in data
    //3 types= +ve,-ve,zero skewness(symmetric data)
    //helps us understand shape n outliers in the dataset
    float mean, median, sd, skewness;

    cout << "Enter the standard deviation: ";
    cin >> sd;
    cout << "Enter the mean: ";
    cin >> mean;
    cout << "Enter the median: ";
    cin >> median;

  // Calculate Karl Pearson Skewness Coefficient
    skewness=3*(mean-median)/sd;
    cout << "Karl Pearson Skewness: " << skewness << endl;
    if(skewness>0&&skewness<3){cout<<"data is positively skewed"<<endl;}
    else if(skewness<0&&skewness>-3){cout<<"data is negatively skewed"<<endl;}
    else{ cout<<"data is symmetric"<<endl;}
  return 0;
}
/////////////////////////////////////////////////////////////////////////////////////

spearman rank Coefficient

#include<iostream>
#include<cmath>
using namespace std;
int main(){
    //used to determine relationship or association between 2 qualitative characteristics
    int arr1[20], arr2[20], arr3[20], arr4[20], n, apple, nn;
    float mango=0.0, rankss;
    cout<<"enter number of elements"<<endl;
    cin>>n;

    cout<<"enter elements of 1st observation table"<<endl;
    for(int i=0;i<n;i++){
        cin>>arr1[i];
    }

    cout<<"enter elements of 2nd observation table"<<endl;
    for(int i=0;i<n;i++){
        cin>>arr2[i];
    }
    cout<<"enter ranks of 1st observation table"<<endl;
    for(int i=0;i<n;i++){
        cin>>arr3[i];
    }

    cout<<"enter ranks of 2nd observation table"<<endl;
    for(int i=0;i<n;i++){
        cin>>arr4[i];
    }

    for(int i=0;i<n;i++){
        apple=arr3[i]-arr4[i];
        mango=mango+(1.0*apple*apple);
    }
    nn=n*n;
    rankss= 1- ((6.0*mango)/(n*(nn-1)));
    cout<<"rank correlation using Spearman's coefficient="<<rankss<<endl;
}
////////////////////////////////////////////////////////////////////////////////////

chi square

#include<iostream>
using namespace std;
int main(){
    //used for hypothesis testiing
    //checks difference between observed and expected value, compared to critical value and then decided to accept or not
    int o[10], e[10], n, dude;
    float man=0.0, boy, chi, cv;
    cout<<"no. of elements"<<endl;
    cin>>n;
    cout<<"observed elements"<<endl;
    for(int i=0;i<n;i++){
        cin>>o[i];
    }
    cout<<"expected elements corresponding to observed elements"<<endl;
    for(int i=0;i<n;i++){
        cin>>e[i];
    }
    for(int i=0;i<n;i++){
        dude=o[i]-e[i];
        boy=1.0*(dude*dude)/e[i]*1.0;
        man=man+boy;
    }
    chi=man;
    cout<<"chi square value:"<<chi<<endl;
    cout<<"enter critical value"<<endl;
    cin>>cv;
    if(cv>=chi){cout<<"value accepted"<<endl;}
    else{cout<<"chi square value rejected"<<endl;}
}
/////////////////////////////////////////////////////////////////////////////////
